[0.00145512 0.25004417 0.24382397 0.50467675]
[[9.98875538e-01 8.91124937e-05 1.56365630e-04 8.78984332e-04]
 [1.08845061e-04 9.99654867e-01 1.23241521e-04 1.13046168e-04]
 [6.04405178e-04 1.09481144e-04 9.98951995e-01 3.34119022e-04]
 [1.67224514e-01 1.23663466e-04 2.75591632e-04 8.32376231e-01]]
[[0.00866923 0.24170898 0.1536958  0.60397149]
 [0.43584833 0.22247633 0.34250751 0.0091682 ]
 [0.00258887 0.6408484  0.10029156 0.26655671]
 [0.01810385 0.33642177 0.02416293 0.63405246]]
[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
上面是某一次的运行结果,从上到下分别是pi,A,B
从结果上看,pi和初始的赋值变化不大,
矩阵A有一个特点就是对角线的元素基本上快要等于1了,反应在训练数据集上就是状态到状态自身的变化数据
非常多,状态转换的数据相对来说比较少,比如训练数据中的:
[3], [3], [3], [1], [3], [1], [3], [3], [3], [1], [2], [3], [3], [1], [3]]
这基本上是状态3到状态3,状态3到状态1的变化都很少,所以最后会出现对角线元素基本上为1的情形,为了
改变这种情形,数据转换最好多一些,或者可以尝试着将显示变量边多一些,变为6维的
这样最后预测出来的数据才会有些变化的,要不然就像最后的结果,基本上是1个状态不会改变的!!!!
上面最初这样设置训练数据的初衷是为了尽可能的分辨出异常的账号,反而弄巧成拙了!!!!